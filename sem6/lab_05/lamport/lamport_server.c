/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <stdbool.h>
#include <sys/time.h>
#include <time.h>

#include "lamport.h"

struct thread_arg_t
{
	int id;
	int num;
	char symb;
};

#define MAX_CLIENTS 100

bool_t choosing[MAX_CLIENTS] = { FALSE };
int numbers[MAX_CLIENTS] = { 0 };

int cur_id = 0;
char cur_symb = 'a';

pthread_t threads[MAX_CLIENTS];
struct thread_arg_t threads_results[MAX_CLIENTS] = { 0 };

void* get_service(void* arg) {
	printf("joined get_service\n");
	sleep(1);
	struct thread_arg_t* targ = arg;
	int i = targ->id;
	
	for (int j = 0; j < MAX_CLIENTS; j++)
	{
		while (choosing[j]);
		while ((numbers[j] > 0) && (numbers[j] < numbers[i] || (numbers[j] == numbers[i] && j < i)));
	}

	targ->symb = cur_symb;
	cur_symb++;
	if (cur_symb > 'z')
		cur_symb = 'a';
	numbers[i] = 0;

	return 0;
}

struct BAKERY* get_num_1_svc(struct BAKERY* argp, struct svc_req* rqstp) {
	static struct BAKERY result;
	int i = cur_id;
	cur_id++;
	if (cur_id == MAX_CLIENTS)
		cur_id = 0;

	choosing[i] = true;

	int max = 0;
	for (int j = 0; j < MAX_CLIENTS; j++)
		if (numbers[j] > max)
			max = numbers[j];

	numbers[i] = max + 1;
	result.id = i;
	result.num = numbers[i];

	choosing[i] = false;

	printf("return get_num_1_svc result: %d %d\n", result.id, result.num);
	return &result;
}

struct BAKERY* wait_res_1_svc(struct BAKERY* argp, struct svc_req* rqstp) {
	static struct BAKERY  result;
	pthread_t thread;
	int i = argp->id;
	threads_results[i].id = i;
	pthread_create(&thread, NULL, get_service, &threads_results[i]);
	sleep(5);
	threads[i] = thread;
	result.symb = threads_results[i].symb;

	printf("return wait_res_1_svc result: %d %d\n", result.num, result.symb);
	return &result;
}

struct BAKERY* get_res_1_svc(struct BAKERY* argp, struct svc_req* rqstp) {
	static struct BAKERY  result;

	pthread_join(threads[argp->id], NULL);
	sleep(5);
	result.id = argp->id;
	result.symb = threads_results[argp->id].symb;

	return &result;
}
